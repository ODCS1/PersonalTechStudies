"use strict";
/**
 * TYPE ASSERTION IS A WAY TO TELL THE TYPESCRIPT COMPILER TO TREAT
 * A VALUE AS A CERTAIN TYPE, EVEN IF TS CANNOT INFER THAT TYPE BY
 * ITSELF. IT´S A POWERFUL FEATURE THAT LETS "ASSERT" THE TYPE OF A
 * VALUE WHEN YOU ARE CONFIDENT ABOUT IT, OVERRIDING TS TYPE
 * INFERENCE.
 */
// 1 - SYNTAX FOR TYPE ASSERTION
// THERE ARE TWO WAYS TO PERFORM TYPE ASSERTIONS IN TS
// A - USING THE "AS" KEYWORD (PREFERRED IN MODERN TS)
let value = "Hello, TypeScript!";
let len = value.length;
// B - USING ANGLE-BRACKET SYNTAX
let len2 = value.length;
// 2 - WHEN TO USE TYPE ASSERTIONS
/**
 * TYPE ASSERTIONS SHOULD BE USED WHEN YOU ARE CERTAIN THAT A VALUE
 * IS OF A SPECIFIC TYPE BUT TS CAN´T DEDUCE IT.
 */
// HERE ARE A FEW COMMON SCENARIOS WHERE TYPE ASSERTIONS ARE USEFUL:
// A - WORKING WITH "any" TYPE
/**
 * IF A VARIABLE HAS THE "any" TYPE, TS WON´T PROVIDE TYPE CHECKING,
 * SO YOU CAN ASSERT A MORE SPECIFIC TYPE WHEN NEEDED.
 */
let someValue = "THIS IS A STRING";
let strLength = someValue.length;
// B - NARROWING DOWN "null" OR "undefined" VALUES
/**
 * IF YOU KNOW THAT A VALUE CANNOT BE "null" OR "undefined" AT A CERTAIN POINT
 * IN THE CODE, YOU CAN ASSERT IT TO A NON-NULLABLE TYPE.
 */
// let element = document.querySelector("#myElement");
let element = document.body;
element.style.backgroundColor = "cyan";
// ASSUME THIS FETCHES USER DATA
// let response: any = fetchUserData();
// ASSERT THAT RESPONSE IS A USER OBJECT
// let l5_user = response as User;
// 3 - TYPE ASSERTION VS TYPE CASTING
/**
 * TYPE ASSERTIONS IN TYPESCRIPT ARE NOT THE SAME AS TYPE CASTING IN OTHER LANGUAGES.
 * TYPE ASSERTIONS ONLY INFLUENCE THE TYPE SYSTEM AT COMPILE-TIME AND DO NOT
 * PERFORM ANY RUNTIME TYPE CONVERSIONS.
 */
// EXAMPLE OF TYPE ASSERTION WITHOUT RUNTIME CHANGE:
let num = 123;
let strValue = num; // NO TYPE CONVERSION IS MADE
console.log(strValue.length); // RUN TIME ERROR
// 4 - WHEN TO AVOID TYPE ASSERTIONS
/**
 * TYPE ASSERTIONS SHOULD BE USED SPARINGLY, AS THEY BYPASS IS'S TYPE CHECKING,
 * WHICH CAN LEAD TO RUNTIME ERRORS IF USED INCORRECTLY.
 * ALWAYS TRY TO RELY ON TS TYPE INFERENCING AND NARROWING INSTEAD.
 */
// AVOID ASSERTING TYPES THAT YOU ARE UNSURE ABOUT:
let userData = { name: "John" };
let age = userData.age;
// 5 - CONCLUSION
/**
 * TYPE ASSERTIONS IN TYPESCRIPT PROVIDE A WAY TO OVERRIDE THE DEFAULT TYPE CHECKING.
 * THEY ARE USEFUL WHEN YOU ARE CERTAIN ABOUT A VALUE'S TYPE, BUT TYPE INFERENCE CANNOT
 * AUTOMATICALLY DEDUCE IT. HOWEVER, USE TYPE ASSERTIONS CAREFULLY TO AVOID
 * POTENTIAL RUNTIME ERRORS.
 */
